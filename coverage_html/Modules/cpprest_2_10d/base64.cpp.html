<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>base64.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/***
 * Copyright (C) Microsoft. All rights reserved.
 * Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
 *
 * =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 *
 * For the latest on this and related APIs, please see: https://github.com/Microsoft/cpprestsdk
 *
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 ****/
#include "stdafx.h"

using namespace web;
using namespace utility;

std::vector&lt;unsigned char&gt; _from_base64(const utility::string_t&amp; str);
utility::string_t _to_base64(const unsigned char* ptr, size_t size);

<span style = "background-color:#fdd">std::vector&lt;unsigned char&gt; __cdecl conversions::from_base64(const utility::string_t&amp; str) { return _from_base64(str); }</span>

utility::string_t __cdecl conversions::to_base64(const std::vector&lt;unsigned char&gt;&amp; input)
<span style = "background-color:#fdd">{
    if (input.size() == 0)</span>
    {
        // return empty string
<span style = "background-color:#fdd">        return utility::string_t();</span>
    }

<span style = "background-color:#fdd">    return _to_base64(&amp;input[0], input.size());
}</span>

utility::string_t __cdecl conversions::to_base64(uint64_t input)
<span style = "background-color:#fdd">{
    return _to_base64(reinterpret_cast&lt;const unsigned char*&gt;(&amp;input), sizeof(input));
}</span>

static const char* _base64_enctbl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const std::array&lt;unsigned char, 128&gt; _base64_dectbl = {
    {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62,
     255, 255, 255, 63,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  255, 255, 255, 254, 255, 255, 255, 0,
     1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,
     23,  24,  25,  255, 255, 255, 255, 255, 255, 26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
     39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  255, 255, 255, 255, 255}};

struct _triple_byte
{
    unsigned char _1_1 : 2;
    unsigned char _0 : 6;
    unsigned char _2_1 : 4;
    unsigned char _1_2 : 4;
    unsigned char _3 : 6;
    unsigned char _2_2 : 2;
};

struct _double_byte
{
    unsigned char _1_1 : 2;
    unsigned char _0 : 6;
    unsigned char _2_1 : 4;
    unsigned char _1_2 : 4;
};

struct _single_byte
{
    unsigned char _1_1 : 2;
    unsigned char _0 : 6;
};

//
// A note on the implementation of BASE64 encoding and decoding:
//
// This is a fairly basic and naive implementation; there is probably a lot of room for
// performance improvement, as well as for adding options such as support for URI-safe base64,
// ignoring CRLF, relaxed validation rules, etc. The decoder is currently pretty strict.
//

#ifdef __GNUC__
// gcc is concerned about the bitfield uses in the code, something we simply need to ignore.
#pragma GCC diagnostic ignored "-Wconversion"
#endif
std::vector&lt;unsigned char&gt; _from_base64(const utility::string_t&amp; input)
<span style = "background-color:#fdd">{
    std::vector&lt;unsigned char&gt; result;</span>

<span style = "background-color:#fdd">    if (input.empty()) return result;</span>

<span style = "background-color:#fdd">    size_t padding = 0;</span>

    // Validation
    {
<span style = "background-color:#fdd">        auto size = input.size();</span>

<span style = "background-color:#fdd">        if ((size % 4) != 0)</span>
        {
<span style = "background-color:#fdd">            throw std::runtime_error("length of base64 string is not an even multiple of 4");</span>
        }

<span style = "background-color:#fdd">        for (auto iter = input.begin(); iter != input.end(); ++iter, --size)</span>
        {
<span style = "background-color:#fdd">            const size_t ch_sz = static_cast&lt;size_t&gt;(*iter);
            if (ch_sz &gt;= _base64_dectbl.size() || _base64_dectbl[ch_sz] == 255)</span>
            {
<span style = "background-color:#fdd">                throw std::runtime_error("invalid character found in base64 string");</span>
            }
<span style = "background-color:#fdd">            if (_base64_dectbl[ch_sz] == 254)</span>
            {
<span style = "background-color:#fdd">                padding++;</span>
                // padding only at the end
<span style = "background-color:#fdd">                if (size &gt; 2)</span>
                {
<span style = "background-color:#fdd">                    throw std::runtime_error("invalid padding character found in base64 string");</span>
                }
<span style = "background-color:#fdd">                if (size == 2)</span>
                {
<span style = "background-color:#fdd">                    const size_t ch2_sz = static_cast&lt;size_t&gt;(*(iter + 1));
                    if (ch2_sz &gt;= _base64_dectbl.size() || _base64_dectbl[ch2_sz] != 254)</span>
                    {
<span style = "background-color:#fdd">                        throw std::runtime_error("invalid padding character found in base64 string");</span>
                    }
                }
<span style = "background-color:#fdd">            }
        }</span>
    }

<span style = "background-color:#fdd">    auto size = input.size();
    const char_t* ptr = &amp;input[0];</span>

<span style = "background-color:#fdd">    auto outsz = (size / 4) * 3;
    outsz -= padding;</span>

<span style = "background-color:#fdd">    result.resize(outsz);</span>

<span style = "background-color:#fdd">    size_t idx = 0;
    for (; size &gt; 4; ++idx)</span>
    {
        unsigned char target[3];
<span style = "background-color:#fdd">        memset(target, 0, sizeof(target));
        _triple_byte* record = reinterpret_cast&lt;_triple_byte*&gt;(target);</span>

<span style = "background-color:#fdd">        unsigned char val0 = _base64_dectbl[ptr[0]];
        unsigned char val1 = _base64_dectbl[ptr[1]];
        unsigned char val2 = _base64_dectbl[ptr[2]];
        unsigned char val3 = _base64_dectbl[ptr[3]];</span>

<span style = "background-color:#fdd">        record-&gt;_0 = val0;
        record-&gt;_1_1 = val1 &gt;&gt; 4;
        result[idx] = target[0];</span>

<span style = "background-color:#fdd">        record-&gt;_1_2 = val1 &amp; 0xF;
        record-&gt;_2_1 = val2 &gt;&gt; 2;
        result[++idx] = target[1];</span>

<span style = "background-color:#fdd">        record-&gt;_2_2 = val2 &amp; 0x3;
        record-&gt;_3 = val3 &amp; 0x3F;
        result[++idx] = target[2];</span>

<span style = "background-color:#fdd">        ptr += 4;
        size -= 4;
    }</span>

    // Handle the last four bytes separately, to avoid having the conditional statements
    // in all the iterations (a performance issue).

    {
        unsigned char target[3];
<span style = "background-color:#fdd">        memset(target, 0, sizeof(target));
        _triple_byte* record = reinterpret_cast&lt;_triple_byte*&gt;(target);</span>

<span style = "background-color:#fdd">        unsigned char val0 = _base64_dectbl[ptr[0]];
        unsigned char val1 = _base64_dectbl[ptr[1]];
        unsigned char val2 = _base64_dectbl[ptr[2]];
        unsigned char val3 = _base64_dectbl[ptr[3]];</span>

<span style = "background-color:#fdd">        record-&gt;_0 = val0;
        record-&gt;_1_1 = val1 &gt;&gt; 4;
        result[idx] = target[0];</span>

<span style = "background-color:#fdd">        record-&gt;_1_2 = val1 &amp; 0xF;
        if (val2 != 254)</span>
        {
<span style = "background-color:#fdd">            record-&gt;_2_1 = val2 &gt;&gt; 2;
            result[++idx] = target[1];
        }</span>
        else
        {
            // There shouldn't be any information (ones) in the unused bits,
<span style = "background-color:#fdd">            if (record-&gt;_1_2 != 0)</span>
            {
<span style = "background-color:#fdd">                throw std::runtime_error("Invalid end of base64 string");</span>
            }
<span style = "background-color:#fdd">            return result;</span>
        }

<span style = "background-color:#fdd">        record-&gt;_2_2 = val2 &amp; 0x3;
        if (val3 != 254)</span>
        {
<span style = "background-color:#fdd">            record-&gt;_3 = val3 &amp; 0x3F;
            result[++idx] = target[2];
        }</span>
        else
        {
            // There shouldn't be any information (ones) in the unused bits.
<span style = "background-color:#fdd">            if (record-&gt;_2_2 != 0)</span>
            {
<span style = "background-color:#fdd">                throw std::runtime_error("Invalid end of base64 string");</span>
            }
<span style = "background-color:#fdd">            return result;</span>
        }
    }

<span style = "background-color:#fdd">    return result;
}</span>

utility::string_t _to_base64(const unsigned char* ptr, size_t size)
<span style = "background-color:#fdd">{
    utility::string_t result;</span>

<span style = "background-color:#fdd">    for (; size &gt;= 3;)</span>
    {
<span style = "background-color:#fdd">        const _triple_byte* record = reinterpret_cast&lt;const _triple_byte*&gt;(ptr);
        unsigned char idx0 = record-&gt;_0;
        unsigned char idx1 = (record-&gt;_1_1 &lt;&lt; 4) | record-&gt;_1_2;
        unsigned char idx2 = (record-&gt;_2_1 &lt;&lt; 2) | record-&gt;_2_2;
        unsigned char idx3 = record-&gt;_3;
        result.push_back(char_t(_base64_enctbl[idx0]));
        result.push_back(char_t(_base64_enctbl[idx1]));
        result.push_back(char_t(_base64_enctbl[idx2]));
        result.push_back(char_t(_base64_enctbl[idx3]));
        size -= 3;
        ptr += 3;
    }
    switch (size)</span>
    {
        case 1:
        {
<span style = "background-color:#fdd">            const _single_byte* record = reinterpret_cast&lt;const _single_byte*&gt;(ptr);
            unsigned char idx0 = record-&gt;_0;
            unsigned char idx1 = (record-&gt;_1_1 &lt;&lt; 4);
            result.push_back(char_t(_base64_enctbl[idx0]));
            result.push_back(char_t(_base64_enctbl[idx1]));
            result.push_back('=');
            result.push_back('=');
            break;</span>
        }
        case 2:
        {
<span style = "background-color:#fdd">            const _double_byte* record = reinterpret_cast&lt;const _double_byte*&gt;(ptr);
            unsigned char idx0 = record-&gt;_0;
            unsigned char idx1 = (record-&gt;_1_1 &lt;&lt; 4) | record-&gt;_1_2;
            unsigned char idx2 = (record-&gt;_2_1 &lt;&lt; 2);
            result.push_back(char_t(_base64_enctbl[idx0]));
            result.push_back(char_t(_base64_enctbl[idx1]));
            result.push_back(char_t(_base64_enctbl[idx2]));
            result.push_back('=');</span>
            break;
        }
    }
<span style = "background-color:#fdd">    return result;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>