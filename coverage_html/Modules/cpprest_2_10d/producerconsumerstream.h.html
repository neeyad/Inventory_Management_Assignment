<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>producerconsumerstream.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/***
 * Copyright (C) Microsoft. All rights reserved.
 * Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
 *
 * =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 *
 * This file defines a basic memory-based stream buffer, which allows consumer / producer pairs to communicate
 * data via a buffer.
 *
 * For the latest on this and related APIs, please see: https://github.com/Microsoft/cpprestsdk
 *
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 ****/
#pragma once

#ifndef CASA_PRODUCER_CONSUMER_STREAMS_H
#define CASA_PRODUCER_CONSUMER_STREAMS_H

#include "cpprest/astreambuf.h"
#include "pplx/pplxtasks.h"
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

namespace Concurrency
{
namespace streams
{
namespace details
{
/// &lt;summary&gt;
/// The basic_producer_consumer_buffer class serves as a memory-based steam buffer that supports both writing and
/// reading sequences of characters. It can be used as a consumer/producer buffer.
/// &lt;/summary&gt;
template&lt;typename _CharType&gt;
class basic_producer_consumer_buffer : public streams::details::streambuf_state_manager&lt;_CharType&gt;
{
public:
    typedef typename ::concurrency::streams::char_traits&lt;_CharType&gt; traits;
    typedef typename basic_streambuf&lt;_CharType&gt;::int_type int_type;
    typedef typename basic_streambuf&lt;_CharType&gt;::pos_type pos_type;
    typedef typename basic_streambuf&lt;_CharType&gt;::off_type off_type;

    /// &lt;summary&gt;
    /// Constructor
    /// &lt;/summary&gt;
    basic_producer_consumer_buffer(size_t alloc_size)
<span style = "background-color:#fdd">        : streambuf_state_manager&lt;_CharType&gt;(std::ios_base::out | std::ios_base::in)
        , m_mode(std::ios_base::in)
        , m_alloc_size(alloc_size)
        , m_allocBlock(nullptr)
        , m_total(0)
        , m_total_read(0)
        , m_total_written(0)
        , m_synced(0)
    {
    }</span>

    /// &lt;summary&gt;
    /// Destructor
    /// &lt;/summary&gt;
    virtual ~basic_producer_consumer_buffer()
<span style = "background-color:#fdd">    {</span>
        // Note: there is no need to call 'wait()' on the result of close(),
        // since we happen to know that close() will return without actually
        // doing anything asynchronously. Should the implementation of _close_write()
        // change in that regard, this logic may also have to change.
<span style = "background-color:#fdd">        this-&gt;_close_read();
        this-&gt;_close_write();</span>

<span style = "background-color:#fdd">        _ASSERTE(m_requests.empty());
        m_blocks.clear();
    }</span>

    /// &lt;summary&gt;
    /// &lt;c&gt;can_seek&lt;c/&gt; is used to determine whether a stream buffer supports seeking.
    /// &lt;/summary&gt;
<span style = "background-color:#fdd">    virtual bool can_seek() const { return false; }</span>

    /// &lt;summary&gt;
    /// &lt;c&gt;has_size&lt;c/&gt; is used to determine whether a stream buffer supports size().
    /// &lt;/summary&gt;
<span style = "background-color:#fdd">    virtual bool has_size() const { return false; }</span>

    /// &lt;summary&gt;
    /// Get the stream buffer size, if one has been set.
    /// &lt;/summary&gt;
    /// &lt;param name="direction"&gt;The direction of buffering (in or out)&lt;/param&gt;
    /// &lt;remarks&gt;An implementation that does not support buffering will always return '0'.&lt;/remarks&gt;
<span style = "background-color:#fdd">    virtual size_t buffer_size(std::ios_base::openmode = std::ios_base::in) const { return 0; }</span>

    /// &lt;summary&gt;
    /// Sets the stream buffer implementation to buffer or not buffer.
    /// &lt;/summary&gt;
    /// &lt;param name="size"&gt;The size to use for internal buffering, 0 if no buffering should be done.&lt;/param&gt;
    /// &lt;param name="direction"&gt;The direction of buffering (in or out)&lt;/param&gt;
    /// &lt;remarks&gt;An implementation that does not support buffering will silently ignore calls to this function and it
    /// will not have any effect on what is returned by subsequent calls to &lt;see cref="::buffer_size method"
    /// /&gt;.&lt;/remarks&gt;
<span style = "background-color:#fdd">    virtual void set_buffer_size(size_t, std::ios_base::openmode = std::ios_base::in) { return; }</span>

    /// &lt;summary&gt;
    /// For any input stream, &lt;c&gt;in_avail&lt;/c&gt; returns the number of characters that are immediately available
    /// to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without
    /// incurring the overhead of using tasks.
    /// &lt;/summary&gt;
<span style = "background-color:#fdd">    virtual size_t in_avail() const { return m_total; }</span>

    /// &lt;summary&gt;
    /// Gets the current read or write position in the stream.
    /// &lt;/summary&gt;
    /// &lt;param name="direction"&gt;The I/O direction to seek (see remarks)&lt;/param&gt;
    /// &lt;returns&gt;The current position. EOF if the operation fails.&lt;/returns&gt;
    /// &lt;remarks&gt;Some streams may have separate write and read cursors.
    ///          For such streams, the direction parameter defines whether to move the read or the write
    ///          cursor.&lt;/remarks&gt;
    virtual pos_type getpos(std::ios_base::openmode mode) const
<span style = "background-color:#fdd">    {
        if (((mode &amp; std::ios_base::in) &amp;&amp; !this-&gt;can_read()) || ((mode &amp; std::ios_base::out) &amp;&amp; !this-&gt;can_write()))
            return static_cast&lt;pos_type&gt;(traits::eof());</span>

<span style = "background-color:#fdd">        if (mode == std::ios_base::in)
            return (pos_type)m_total_read;
        else if (mode == std::ios_base::out)
            return (pos_type)m_total_written;</span>
        else
<span style = "background-color:#fdd">            return (pos_type)traits::eof();
    }</span>

    // Seeking is not supported
<span style = "background-color:#fdd">    virtual pos_type seekpos(pos_type, std::ios_base::openmode) { return (pos_type)traits::eof(); }</span>
    virtual pos_type seekoff(off_type, std::ios_base::seekdir, std::ios_base::openmode)
<span style = "background-color:#fdd">    {
        return (pos_type)traits::eof();
    }</span>

    /// &lt;summary&gt;
    /// Allocates a contiguous memory block and returns it.
    /// &lt;/summary&gt;
    /// &lt;param name="count"&gt;The number of characters to allocate.&lt;/param&gt;
    /// &lt;returns&gt;A pointer to a block to write to, null if the stream buffer implementation does not support
    /// alloc/commit.&lt;/returns&gt;
    virtual _CharType* _alloc(size_t count)
<span style = "background-color:#fdd">    {
        if (!this-&gt;can_write())</span>
        {
<span style = "background-color:#fdd">            return nullptr;</span>
        }

        // We always allocate a new block even if the count could be satisfied by
        // the current write block. While this does lead to wasted space it allows for
        // easier book keeping

<span style = "background-color:#fdd">        _ASSERTE(!m_allocBlock);
        m_allocBlock = std::make_shared&lt;_block&gt;(count);
        return m_allocBlock-&gt;wbegin();
    }</span>

    /// &lt;summary&gt;
    /// Submits a block already allocated by the stream buffer.
    /// &lt;/summary&gt;
    /// &lt;param name="count"&gt;The number of characters to be committed.&lt;/param&gt;
    virtual void _commit(size_t count)
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);</span>

        // The count does not reflect the actual size of the block.
        // Since we do not allow any more writes to this block it would suffice.
        // If we ever change the algorithm to reuse blocks then this needs to be revisited.

<span style = "background-color:#fdd">        _ASSERTE((bool)m_allocBlock);
        m_allocBlock-&gt;update_write_head(count);
        m_blocks.push_back(m_allocBlock);
        m_allocBlock = nullptr;</span>

<span style = "background-color:#fdd">        update_write_head(count);
    }</span>

    /// &lt;summary&gt;
    /// Gets a pointer to the next already allocated contiguous block of data.
    /// &lt;/summary&gt;
    /// &lt;param name="ptr"&gt;A reference to a pointer variable that will hold the address of the block on success.&lt;/param&gt;
    /// &lt;param name="count"&gt;The number of contiguous characters available at the address in 'ptr'.&lt;/param&gt;
    /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the operation succeeded, &lt;c&gt;false&lt;/c&gt; otherwise.&lt;/returns&gt;
    /// &lt;remarks&gt;
    /// A return of false does not necessarily indicate that a subsequent read operation would fail, only that
    /// there is no block to return immediately or that the stream buffer does not support the operation.
    /// The stream buffer may not de-allocate the block until &lt;see cref="::release method" /&gt; is called.
    /// If the end of the stream is reached, the function will return &lt;c&gt;true&lt;/c&gt;, a null pointer, and a count of zero;
    /// a subsequent read will not succeed.
    /// &lt;/remarks&gt;
    virtual bool acquire(_Out_ _CharType*&amp; ptr, _Out_ size_t&amp; count)
<span style = "background-color:#fdd">    {
        count = 0;
        ptr = nullptr;</span>

<span style = "background-color:#fdd">        if (!this-&gt;can_read()) return false;</span>

<span style = "background-color:#fdd">        pplx::extensibility::scoped_critical_section_t l(m_lock);</span>

<span style = "background-color:#fdd">        if (m_blocks.empty())</span>
        {
            // If the write head has been closed then have reached the end of the
            // stream (return true), otherwise more data could be written later (return false).
<span style = "background-color:#fdd">            return !this-&gt;can_write();
        }</span>
        else
        {
<span style = "background-color:#fdd">            auto block = m_blocks.front();</span>

<span style = "background-color:#fdd">            count = block-&gt;rd_chars_left();
            ptr = block-&gt;rbegin();</span>

<span style = "background-color:#fdd">            _ASSERTE(ptr != nullptr);
            return true;</span>
        }
<span style = "background-color:#fdd">    }</span>

    /// &lt;summary&gt;
    /// Releases a block of data acquired using &lt;see cref="::acquire method"/&gt;. This frees the stream buffer to
    /// de-allocate the memory, if it so desires. Move the read position ahead by the count.
    /// &lt;/summary&gt;
    /// &lt;param name="ptr"&gt;A pointer to the block of data to be released.&lt;/param&gt;
    /// &lt;param name="count"&gt;The number of characters that were read.&lt;/param&gt;
    virtual void release(_Out_writes_opt_(count) _CharType* ptr, _In_ size_t count)
<span style = "background-color:#fdd">    {
        if (ptr == nullptr) return;</span>

<span style = "background-color:#fdd">        pplx::extensibility::scoped_critical_section_t l(m_lock);
        auto block = m_blocks.front();</span>

<span style = "background-color:#fdd">        _ASSERTE(block-&gt;rd_chars_left() &gt;= count);
        block-&gt;m_read += count;</span>

<span style = "background-color:#fdd">        update_read_head(count);
    }</span>

protected:
    virtual pplx::task&lt;bool&gt; _sync()
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);</span>

<span style = "background-color:#fdd">        m_synced = in_avail();</span>

<span style = "background-color:#fdd">        fulfill_outstanding();</span>

<span style = "background-color:#fdd">        return pplx::task_from_result(true);
    }</span>

    virtual pplx::task&lt;int_type&gt; _putc(_CharType ch)
<span style = "background-color:#fdd">    {
        return pplx::task_from_result((this-&gt;write(&amp;ch, 1) == 1) ? static_cast&lt;int_type&gt;(ch) : traits::eof());
    }</span>

    virtual pplx::task&lt;size_t&gt; _putn(const _CharType* ptr, size_t count)
<span style = "background-color:#fdd">    {
        return pplx::task_from_result&lt;size_t&gt;(this-&gt;write(ptr, count));
    }</span>

    virtual pplx::task&lt;size_t&gt; _getn(_Out_writes_(count) _CharType* ptr, _In_ size_t count)
<span style = "background-color:#fdd">    {
        pplx::task_completion_event&lt;size_t&gt; tce;
        enqueue_request(_request(count, [this, ptr, count, tce]() {</span>
            // VS 2010 resolves read to a global function.  Explicit
            // invocation through the "this" pointer fixes the issue.
<span style = "background-color:#fdd">            tce.set(this-&gt;read(ptr, count));
        }));
        return pplx::create_task(tce);
    }</span>

    virtual size_t _sgetn(_Out_writes_(count) _CharType* ptr, _In_ size_t count)
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);
        return can_satisfy(count) ? this-&gt;read(ptr, count) : (size_t)traits::requires_async();
    }</span>

    virtual size_t _scopy(_Out_writes_(count) _CharType* ptr, _In_ size_t count)
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);
        return can_satisfy(count) ? this-&gt;read(ptr, count, false) : (size_t)traits::requires_async();
    }</span>

    virtual pplx::task&lt;int_type&gt; _bumpc()
<span style = "background-color:#fdd">    {
        pplx::task_completion_event&lt;int_type&gt; tce;
        enqueue_request(_request(1, [this, tce]() { tce.set(this-&gt;read_byte(true)); }));
        return pplx::create_task(tce);
    }</span>

    virtual int_type _sbumpc()
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);
        return can_satisfy(1) ? this-&gt;read_byte(true) : traits::requires_async();
    }</span>

    virtual pplx::task&lt;int_type&gt; _getc()
<span style = "background-color:#fdd">    {
        pplx::task_completion_event&lt;int_type&gt; tce;
        enqueue_request(_request(1, [this, tce]() { tce.set(this-&gt;read_byte(false)); }));
        return pplx::create_task(tce);
    }</span>

    int_type _sgetc()
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);
        return can_satisfy(1) ? this-&gt;read_byte(false) : traits::requires_async();
    }</span>

    virtual pplx::task&lt;int_type&gt; _nextc()
<span style = "background-color:#fdd">    {
        pplx::task_completion_event&lt;int_type&gt; tce;
        enqueue_request(_request(1, [this, tce]() {
            this-&gt;read_byte(true);
            tce.set(this-&gt;read_byte(false));
        }));
        return pplx::create_task(tce);
    }</span>

<span style = "background-color:#fdd">    virtual pplx::task&lt;int_type&gt; _ungetc() { return pplx::task_from_result&lt;int_type&gt;(traits::eof()); }</span>

private:
    /// &lt;summary&gt;
    /// Close the stream buffer for writing
    /// &lt;/summary&gt;
    pplx::task&lt;void&gt; _close_write()
<span style = "background-color:#fdd">    {</span>
        // First indicate that there could be no more writes.
        // Fulfill outstanding relies on that to flush all the
        // read requests.
<span style = "background-color:#fdd">        this-&gt;m_stream_can_write = false;</span>

        {
<span style = "background-color:#fdd">            pplx::extensibility::scoped_critical_section_t l(this-&gt;m_lock);</span>

            // This runs on the thread that called close.
<span style = "background-color:#fdd">            this-&gt;fulfill_outstanding();
        }</span>

<span style = "background-color:#fdd">        return pplx::task_from_result();
    }</span>

    /// &lt;summary&gt;
    /// Updates the write head by an offset specified by count
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;This should be called with the lock held&lt;/remarks&gt;
    void update_write_head(size_t count)
<span style = "background-color:#fdd">    {
        m_total += count;
        m_total_written += count;
        fulfill_outstanding();
    }</span>

    /// &lt;summary&gt;
    /// Writes count characters from ptr into the stream buffer
    /// &lt;/summary&gt;
    size_t write(const _CharType* ptr, size_t count)
<span style = "background-color:#fdd">    {
        if (!this-&gt;can_write() || (count == 0)) return 0;</span>

        // If no one is going to read, why bother?
        // Just pretend to be writing!
<span style = "background-color:#fdd">        if (!this-&gt;can_read()) return count;</span>

<span style = "background-color:#fdd">        pplx::extensibility::scoped_critical_section_t l(m_lock);</span>

        // Allocate a new block if necessary
<span style = "background-color:#fdd">        if (m_blocks.empty() || m_blocks.back()-&gt;wr_chars_left() &lt; count)</span>
        {
<span style = "background-color:#fdd">            msl::safeint3::SafeInt&lt;size_t&gt; alloc = m_alloc_size.Max(count);
            m_blocks.push_back(std::make_shared&lt;_block&gt;(alloc));</span>
        }

        // The block at the back is always the write head
<span style = "background-color:#fdd">        auto last = m_blocks.back();
        auto countWritten = last-&gt;write(ptr, count);
        _ASSERTE(countWritten == count);</span>

<span style = "background-color:#fdd">        update_write_head(countWritten);
        return countWritten;
    }</span>

    /// &lt;summary&gt;
    /// Fulfill pending requests
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;This should be called with the lock held&lt;/remarks&gt;
    void fulfill_outstanding()
<span style = "background-color:#fdd">    {
        while (!m_requests.empty())</span>
        {
<span style = "background-color:#fdd">            auto req = m_requests.front();</span>

            // If we cannot satisfy the request then we need
            // to wait for the producer to write data
<span style = "background-color:#fdd">            if (!can_satisfy(req.size())) return;</span>

            // We have enough data to satisfy this request
<span style = "background-color:#fdd">            req.complete();</span>

            // Remove it from the request queue
<span style = "background-color:#fdd">            m_requests.pop();
        }
    }</span>

    /// &lt;summary&gt;
    /// Represents a memory block
    /// &lt;/summary&gt;
    class _block
    {
    public:
<span style = "background-color:#fdd">        _block(size_t size) : m_read(0), m_pos(0), m_size(size), m_data(new _CharType[size]) {}</span>

<span style = "background-color:#fdd">        ~_block() { delete[] m_data; }</span>

        // Read head
        size_t m_read;

        // Write head
        size_t m_pos;

        // Allocation size (of m_data)
        size_t m_size;

        // The data store
        _CharType* m_data;

        // Pointer to the read head
<span style = "background-color:#fdd">        _CharType* rbegin() { return m_data + m_read; }</span>

        // Pointer to the write head
<span style = "background-color:#fdd">        _CharType* wbegin() { return m_data + m_pos; }</span>

        // Read up to count characters from the block
        size_t read(_Out_writes_(count) _CharType* dest, _In_ size_t count, bool advance = true)
<span style = "background-color:#fdd">        {
            msl::safeint3::SafeInt&lt;size_t&gt; avail(rd_chars_left());
            auto countRead = static_cast&lt;size_t&gt;(avail.Min(count));</span>

<span style = "background-color:#fdd">            _CharType* beg = rbegin();
            _CharType* end = rbegin() + countRead;</span>

#if defined(_ITERATOR_DEBUG_LEVEL) &amp;&amp; _ITERATOR_DEBUG_LEVEL != 0
            // Avoid warning C4996: Use checked iterators under SECURE_SCL
<span style = "background-color:#fdd">            std::copy(beg, end, stdext::checked_array_iterator&lt;_CharType*&gt;(dest, count));</span>
#else
            std::copy(beg, end, dest);
#endif // _WIN32

<span style = "background-color:#fdd">            if (advance)</span>
            {
<span style = "background-color:#fdd">                m_read += countRead;</span>
            }

<span style = "background-color:#fdd">            return countRead;
        }</span>

        // Write count characters into the block
        size_t write(const _CharType* src, size_t count)
<span style = "background-color:#fdd">        {
            msl::safeint3::SafeInt&lt;size_t&gt; avail(wr_chars_left());
            auto countWritten = static_cast&lt;size_t&gt;(avail.Min(count));</span>

<span style = "background-color:#fdd">            const _CharType* srcEnd = src + countWritten;</span>

#if defined(_ITERATOR_DEBUG_LEVEL) &amp;&amp; _ITERATOR_DEBUG_LEVEL != 0
            // Avoid warning C4996: Use checked iterators under SECURE_SCL
<span style = "background-color:#fdd">            std::copy(src, srcEnd, stdext::checked_array_iterator&lt;_CharType*&gt;(wbegin(), static_cast&lt;size_t&gt;(avail)));</span>
#else
            std::copy(src, srcEnd, wbegin());
#endif // _WIN32

<span style = "background-color:#fdd">            update_write_head(countWritten);
            return countWritten;
        }</span>

<span style = "background-color:#fdd">        void update_write_head(size_t count) { m_pos += count; }</span>

<span style = "background-color:#fdd">        size_t rd_chars_left() const { return m_pos - m_read; }
        size_t wr_chars_left() const { return m_size - m_pos; }</span>

    private:
        // Copy is not supported
        _block(const _block&amp;);
        _block&amp; operator=(const _block&amp;);
    };

    /// &lt;summary&gt;
    /// Represents a request on the stream buffer - typically reads
    /// &lt;/summary&gt;
    class _request
    {
    public:
        typedef std::function&lt;void()&gt; func_type;
<span style = "background-color:#fdd">        _request(size_t count, const func_type&amp; func) : m_func(func), m_count(count) {}</span>

<span style = "background-color:#fdd">        void complete() { m_func(); }</span>

<span style = "background-color:#fdd">        size_t size() const { return m_count; }</span>

    private:
        func_type m_func;
        size_t m_count;
    };

    void enqueue_request(_request req)
<span style = "background-color:#fdd">    {
        pplx::extensibility::scoped_critical_section_t l(m_lock);</span>

<span style = "background-color:#fdd">        if (can_satisfy(req.size()))</span>
        {
            // We can immediately fulfill the request.
<span style = "background-color:#fdd">            req.complete();
        }</span>
        else
        {
            // We must wait for data to arrive.
<span style = "background-color:#fdd">            m_requests.push(req);</span>
        }
<span style = "background-color:#fdd">    }</span>

    /// &lt;summary&gt;
    /// Determine if the request can be satisfied.
    /// &lt;/summary&gt;
<span style = "background-color:#fdd">    bool can_satisfy(size_t count) { return (m_synced &gt; 0) || (this-&gt;in_avail() &gt;= count) || !this-&gt;can_write(); }</span>

    /// &lt;summary&gt;
    /// Reads a byte from the stream and returns it as int_type.
    /// Note: This routine shall only be called if can_satisfy() returned true.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;This should be called with the lock held&lt;/remarks&gt;
    int_type read_byte(bool advance = true)
<span style = "background-color:#fdd">    {</span>
        _CharType value;
<span style = "background-color:#fdd">        auto read_size = this-&gt;read(&amp;value, 1, advance);
        return read_size == 1 ? static_cast&lt;int_type&gt;(value) : traits::eof();
    }</span>

    /// &lt;summary&gt;
    /// Reads up to count characters into ptr and returns the count of characters copied.
    /// The return value (actual characters copied) could be &lt;= count.
    /// Note: This routine shall only be called if can_satisfy() returned true.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;This should be called with the lock held&lt;/remarks&gt;
    size_t read(_Out_writes_(count) _CharType* ptr, _In_ size_t count, bool advance = true)
<span style = "background-color:#fdd">    {
        _ASSERTE(can_satisfy(count));</span>

<span style = "background-color:#fdd">        size_t read = 0;</span>

<span style = "background-color:#fdd">        for (auto iter = begin(m_blocks); iter != std::end(m_blocks); ++iter)</span>
        {
<span style = "background-color:#fdd">            auto block = *iter;
            auto read_from_block = block-&gt;read(ptr + read, count - read, advance);</span>

<span style = "background-color:#fdd">            read += read_from_block;</span>

<span style = "background-color:#fdd">            _ASSERTE(count &gt;= read);
            if (read == count) break;
        }</span>

<span style = "background-color:#fdd">        if (advance)</span>
        {
<span style = "background-color:#fdd">            update_read_head(read);</span>
        }

<span style = "background-color:#fdd">        return read;
    }</span>

    /// &lt;summary&gt;
    /// Updates the read head by the specified offset
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;This should be called with the lock held&lt;/remarks&gt;
    void update_read_head(size_t count)
<span style = "background-color:#fdd">    {
        m_total -= count;
        m_total_read += count;</span>

<span style = "background-color:#fdd">        if (m_synced &gt; 0) m_synced = (m_synced &gt; count) ? (m_synced - count) : 0;</span>

        // The block at the front is always the read head.
        // Purge empty blocks so that the block at the front reflects the read head
<span style = "background-color:#fdd">        while (!m_blocks.empty())</span>
        {
            // If front block is not empty - we are done
<span style = "background-color:#fdd">            if (m_blocks.front()-&gt;rd_chars_left() &gt; 0) break;</span>

            // The block has no more data to be read. Release the block
<span style = "background-color:#fdd">            m_blocks.pop_front();
        }
    }</span>

    // The in/out mode for the buffer
    std::ios_base::openmode m_mode;

    // Default block size
    msl::safeint3::SafeInt&lt;size_t&gt; m_alloc_size;

    // Block used for alloc/commit
    std::shared_ptr&lt;_block&gt; m_allocBlock;

    // Total available data
    size_t m_total;

    size_t m_total_read;
    size_t m_total_written;

    // Keeps track of the number of chars that have been flushed but still
    // remain to be consumed by a read operation.
    size_t m_synced;

    // The producer-consumer buffer is intended to be used concurrently by a reader
    // and a writer, who are not coordinating their accesses to the buffer (coordination
    // being what the buffer is for in the first place). Thus, we have to protect
    // against some of the internal data elements against concurrent accesses
    // and the possibility of inconsistent states. A simple non-recursive lock
    // should be sufficient for those purposes.
    pplx::extensibility::critical_section_t m_lock;

    // Memory blocks
    std::deque&lt;std::shared_ptr&lt;_block&gt;&gt; m_blocks;

    // Queue of requests
    std::queue&lt;_request&gt; m_requests;
};

} // namespace details

/// &lt;summary&gt;
/// The producer_consumer_buffer class serves as a memory-based steam buffer that supports both writing and reading
/// sequences of bytes. It can be used as a consumer/producer buffer.
/// &lt;/summary&gt;
/// &lt;typeparam name="_CharType"&gt;
/// The data type of the basic element of the &lt;c&gt;producer_consumer_buffer&lt;/c&gt;.
/// &lt;/typeparam&gt;
/// &lt;remarks&gt;
/// This is a reference-counted version of basic_producer_consumer_buffer.&lt;/remarks&gt;
template&lt;typename _CharType&gt;
class producer_consumer_buffer : public streambuf&lt;_CharType&gt;
{
public:
    typedef _CharType char_type;

    /// &lt;summary&gt;
    /// Create a producer_consumer_buffer.
    /// &lt;/summary&gt;
    /// &lt;param name="alloc_size"&gt;The internal default block size.&lt;/param&gt;
    producer_consumer_buffer(size_t alloc_size = 512)
<span style = "background-color:#fdd">        : streambuf&lt;_CharType&gt;(std::make_shared&lt;details::basic_producer_consumer_buffer&lt;_CharType&gt;&gt;(alloc_size))
    {
    }</span>
};

} // namespace streams
} // namespace Concurrency

#endif</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>