<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>http_helpers.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/***
 * Copyright (C) Microsoft. All rights reserved.
 * Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
 *
 * =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 *
 * Implementation Details of the http.h layer of messaging
 *
 * For the latest on this and related APIs, please see: https://github.com/Microsoft/cpprestsdk
 *
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 ****/

#include "stdafx.h"

#include "internal_http_helpers.h"

using namespace web;
using namespace utility;
using namespace utility::conversions;

namespace web
{
namespace http
{
namespace details
{
// Remove once VS 2013 is no longer supported.
#if defined(_WIN32) &amp;&amp; _MSC_VER &lt; 1900
static const http_status_to_phrase idToPhraseMap[] = {
#define _PHRASES
#define DAT(a, b, c) {status_codes::a, c},
#include "cpprest/details/http_constants.dat"
#undef _PHRASES
#undef DAT
};
#endif
utility::string_t get_default_reason_phrase(status_code code)
<span style = "background-color:#fdd">{</span>
#if !defined(_WIN32) || _MSC_VER &gt;= 1900
    // Future improvement: why is this stored as an array of structs instead of a map
    // indexed on the status code for faster lookup?
    // Not a big deal because it is uncommon to not include a reason phrase.
<span style = "background-color:#fdd">    static const http_status_to_phrase idToPhraseMap[] = {</span>
#define _PHRASES
#define DAT(a, b, c) {status_codes::a, c},
#include "cpprest/details/http_constants.dat"
#undef _PHRASES
#undef DAT
    };
#endif

<span style = "background-color:#fdd">    utility::string_t phrase;
    for (const auto&amp; elm : idToPhraseMap)</span>
    {
<span style = "background-color:#fdd">        if (elm.id == code)</span>
        {
<span style = "background-color:#fdd">            phrase = elm.phrase;
            break;</span>
        }
<span style = "background-color:#fdd">    }
    return phrase;
}</span>

size_t chunked_encoding::add_chunked_delimiters(_Out_writes_(buffer_size) uint8_t* data,
                                                _In_ size_t buffer_size,
                                                size_t bytes_read)
<span style = "background-color:#fdd">{
    size_t offset = 0;</span>

<span style = "background-color:#fdd">    if (buffer_size &lt; bytes_read + http::details::chunked_encoding::additional_encoding_space)</span>
    {
<span style = "background-color:#fdd">        throw http_exception(_XPLATSTR("Insufficient buffer size."));</span>
    }

<span style = "background-color:#fdd">    if (bytes_read == 0)</span>
    {
<span style = "background-color:#fdd">        offset = 7;
        data[7] = '0';
        data[8] = '\r';
        data[9] = '\n'; // The end of the size.
        data[10] = '\r';
        data[11] = '\n'; // The end of the message.
    }</span>
    else
    {
        char buffer[9];
#ifdef _WIN32
<span style = "background-color:#fdd">        sprintf_s(buffer, sizeof(buffer), "%8IX", bytes_read);</span>
#else
        snprintf(buffer, sizeof(buffer), "%8zX", bytes_read);
#endif
<span style = "background-color:#fdd">        memcpy(&amp;data[0], buffer, 8);
        while (data[offset] == ' ')
            ++offset;
        data[8] = '\r';
        data[9] = '\n'; // The end of the size.
        data[10 + bytes_read] = '\r';
        data[11 + bytes_read] = '\n'; // The end of the chunk.</span>
    }

<span style = "background-color:#fdd">    return offset;
}</span>

static const std::array&lt;bool, 128&gt; valid_chars = {{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0-15
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16-31
    0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32-47
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48-63
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64-79
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, // 80-95
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96-111
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0  // 112-127
}};

// Checks if the method contains any invalid characters
bool validate_method(const utility::string_t&amp; method)
<span style = "background-color:#fdd">{
    for (const auto&amp; ch : method)</span>
    {
<span style = "background-color:#fdd">        size_t ch_sz = static_cast&lt;size_t&gt;(ch);
        if (ch_sz &gt;= 128) return false;</span>

<span style = "background-color:#fdd">        if (!valid_chars[ch_sz]) return false;
    }</span>

<span style = "background-color:#fdd">    return true;
}</span>

} // namespace details
} // namespace http
} // namespace web</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>