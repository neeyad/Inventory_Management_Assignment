<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>http_server_httpsys.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/***
 * Copyright (C) Microsoft. All rights reserved.
 * Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
 *
 * =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 *
 * HTTP Library: implementation of HTTP server API built on Windows HTTP Server APIs.
 *
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 ****/

#pragma once

#if _WIN32_WINNT &lt; _WIN32_WINNT_VISTA
#error "Error: http server APIs are not supported in XP"
#endif //_WIN32_WINNT &lt; _WIN32_WINNT_VISTA

// Windows Sockets are not code analysis clean.
#pragma warning(push)
#pragma warning(disable : 6386)
#include &lt;http.h&gt;
#pragma warning(pop)

#include "cpprest/details/http_server.h"
#include &lt;atomic&gt;
#include &lt;mutex&gt;

namespace web
{
namespace http
{
namespace experimental
{
namespace details
{
class http_windows_server;
struct windows_request_context;

/// &lt;summary&gt;
/// Class used to wrap OVERLAPPED I/O with any HTTP I/O.
/// &lt;/summary&gt;
class http_overlapped : public OVERLAPPED
{
public:
    void set_http_io_completion(std::function&lt;void(DWORD, DWORD)&gt; http_io_completion)
<span style = "background-color:#fdd">    {
        ZeroMemory(this, sizeof(OVERLAPPED));
        m_http_io_completion = http_io_completion;
    }</span>

    /// &lt;summary&gt;
    /// Callback for all I/O completions.
    /// &lt;/summary&gt;
    static void CALLBACK io_completion_callback(PTP_CALLBACK_INSTANCE instance,
                                                PVOID context,
                                                PVOID pOverlapped,
                                                ULONG result,
                                                ULONG_PTR numberOfBytesTransferred,
                                                PTP_IO io)
<span style = "background-color:#fdd">    {</span>
        (void)io;
        (void)context;
        (void)instance;

<span style = "background-color:#fdd">        http_overlapped* p_http_overlapped = (http_overlapped*)pOverlapped;
        p_http_overlapped-&gt;m_http_io_completion(result, (DWORD)numberOfBytesTransferred);
    }</span>

private:
    std::function&lt;void(DWORD, DWORD)&gt; m_http_io_completion;
};

/// &lt;summary&gt;
/// Context for http request through Windows HTTP Server API.
/// &lt;/summary&gt;
struct windows_request_context : http::details::_http_server_context
{
    windows_request_context();
    virtual ~windows_request_context();

    // Asynchronously starts processing the current request.
    void async_process_request(HTTP_REQUEST_ID request_id, http::http_request msg, const unsigned long headers_size);

    // Dispatch request to the provided http_listener.
    void dispatch_request_to_listener(_In_ web::http::experimental::listener::details::http_listener_impl* pListener);

    enum class ShouldWaitForBody
    {
        Wait,
        DontWait
    };
    // Initialise the response task callbacks. If the body has been requested, we should wait for it to avoid race
    // conditions.
    void init_response_callbacks(ShouldWaitForBody shouldWait);

    // Read in a portion of the request body.
    void read_request_body_chunk();

    // Start processing the response.
    void async_process_response();

    void transmit_body();

    // Read request headers io completion callback function .
    void read_headers_io_completion(DWORD error_code, DWORD bytes_read);

    // Read request body io completion callback function.
    void read_body_io_completion(DWORD error_code, DWORD bytes_read);

    // Send response io completion callback function .
    void send_response_io_completion(DWORD error_code, DWORD bytes_read);

    // Send response body io completion callback function.
    void send_response_body_io_completion(DWORD error_code, DWORD bytes_read);

    // Cancel request io completion callback function.
    void cancel_request_io_completion(DWORD error_code, DWORD bytes_read);

    // TCE that indicates the completion of response
    // Workaround for ppl task_completion_event bug.
    std::mutex m_responseCompletedLock;
    pplx::task_completion_event&lt;void&gt; m_response_completed;

    // Id of the currently processed request on this connection.
    HTTP_REQUEST_ID m_request_id;

    bool m_sending_in_chunks;
    bool m_transfer_encoding;

    size_t m_remaining_to_write;

    HTTP_REQUEST* m_request;
    std::unique_ptr&lt;unsigned char[]&gt; m_request_buffer;

    std::unique_ptr&lt;HTTP_UNKNOWN_HEADER[]&gt; m_headers;
    std::vector&lt;std::string&gt; m_headers_buffer;

    http_overlapped m_overlapped;

    http_request m_msg;
    http_response m_response;

    std::exception_ptr m_except_ptr;

    std::vector&lt;uint8_t&gt; m_compress_buffer;
    std::unique_ptr&lt;web::http::compression::compress_provider&gt; m_compressor;
    std::unique_ptr&lt;web::http::compression::decompress_provider&gt; m_decompressor;
    utility::string_t m_decompress_header;
    http::compression::details::header_types m_decompress_header_type;

private:
    windows_request_context(const windows_request_context&amp;);
    windows_request_context&amp; operator=(const windows_request_context&amp;);

    // Sends entity body chunk.
    void send_entity_body(_In_reads_(data_length) unsigned char* data, _In_ size_t data_length);

    // Cancels this request.
    void cancel_request(std::exception_ptr except_ptr);

    std::vector&lt;unsigned char&gt; m_body_data;
};

/// &lt;summary&gt;
/// Class to implement HTTP server API on Windows.
/// &lt;/summary&gt;
class http_windows_server : public http_server
{
public:
    /// &lt;summary&gt;
    /// Constructs a http_windows_server.
    /// &lt;/summary&gt;
    http_windows_server();

    /// &lt;summary&gt;
    /// Releases resources held.
    /// &lt;/summary&gt;
    ~http_windows_server();

    /// &lt;summary&gt;
    /// Start listening for incoming requests.
    /// &lt;/summary&gt;
    virtual pplx::task&lt;void&gt; start();

    /// &lt;summary&gt;
    /// Registers an http listener.
    /// &lt;/summary&gt;
    virtual pplx::task&lt;void&gt; register_listener(
        _In_ web::http::experimental::listener::details::http_listener_impl* pListener);

    /// &lt;summary&gt;
    /// Unregisters an http listener.
    /// &lt;/summary&gt;
    virtual pplx::task&lt;void&gt; unregister_listener(
        _In_ web::http::experimental::listener::details::http_listener_impl* pListener);

    /// &lt;summary&gt;
    /// Stop processing and listening for incoming requests.
    /// &lt;/summary&gt;
    virtual pplx::task&lt;void&gt; stop();

    /// &lt;summary&gt;
    /// Asynchronously sends the specified http response.
    /// &lt;/summary&gt;
    /// &lt;param name="response"&gt;The http_response to send.&lt;/param&gt;
    /// &lt;returns&gt;A operation which is completed once the response has been sent.&lt;/returns&gt;
    virtual pplx::task&lt;void&gt; respond(http::http_response response);

private:
    friend struct details::windows_request_context;

    // Structure to hold each registered listener.
    class listener_registration
    {
    public:
<span style = "background-color:#dfd">        listener_registration(HTTP_URL_GROUP_ID urlGroupId) : m_urlGroupId(urlGroupId) {}</span>

        // URL group id for this listener. Each listener needs it own URL group
        // because configuration like timeouts, authentication, etc...
        HTTP_URL_GROUP_ID m_urlGroupId;

        // Request handler lock to guard against removing a listener while in user code.
        pplx::extensibility::reader_writer_lock_t m_requestHandlerLock;
    };

    // Registered listeners
    pplx::extensibility::reader_writer_lock_t _M_listenersLock;
    std::unordered_map&lt;web::http::experimental::listener::details::http_listener_impl*,
                       std::unique_ptr&lt;listener_registration&gt;&gt;
        _M_registeredListeners;

    // HTTP Server API server session id.
    HTTP_SERVER_SESSION_ID m_serverSessionId;

    // Tracks the number of outstanding requests being processed.
    std::atomic&lt;int&gt; m_numOutstandingRequests;
    pplx::extensibility::event_t m_zeroOutstandingRequests;

    // Handle to HTTP Server API request queue.
    HANDLE m_hRequestQueue;

    // Threadpool I/O structure for overlapped I/O.
    TP_IO* m_threadpool_io;

    // Task which actually handles receiving requests from HTTP Server API request queue.
    pplx::task&lt;void&gt; m_receivingTask;
    void receive_requests();
};

} // namespace details
} // namespace experimental
} // namespace http
} // namespace web</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>