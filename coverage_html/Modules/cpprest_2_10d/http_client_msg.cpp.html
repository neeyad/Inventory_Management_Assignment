<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>http_client_msg.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/***
 * Copyright (C) Microsoft. All rights reserved.
 * Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
 *
 * =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 *
 * HTTP Library: Request and reply message definitions (client side).
 *
 * For the latest on this and related APIs, please see: https://github.com/Microsoft/cpprestsdk
 *
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 ****/
#include "stdafx.h"

#include "../common/internal_http_helpers.h"
#include "cpprest/asyncrt_utils.h"

namespace web
{
namespace http
{
uri details::_http_request::relative_uri() const
<span style = "background-color:#fdd">{</span>
    // If the listener path is empty, then just return the request URI.
<span style = "background-color:#fdd">    if (m_listener_path.empty() || m_listener_path == _XPLATSTR("/"))</span>
    {
<span style = "background-color:#fdd">        return m_uri.resource();</span>
    }

<span style = "background-color:#fdd">    utility::string_t prefix = uri::decode(m_listener_path);
    utility::string_t path = uri::decode(m_uri.resource().to_string());
    if (path.empty())</span>
    {
<span style = "background-color:#fdd">        path = _XPLATSTR("/");</span>
    }

<span style = "background-color:#fdd">    auto pos = path.find(prefix);
    if (pos == 0)</span>
    {
<span style = "background-color:#fdd">        return uri(uri::encode_uri(path.erase(0, prefix.length())));
    }</span>
    else
    {
<span style = "background-color:#fdd">        throw http_exception(_XPLATSTR("Error: request was not prefixed with listener uri"));</span>
    }
<span style = "background-color:#fdd">}</span>

uri details::_http_request::absolute_uri() const
<span style = "background-color:#fdd">{
    if (m_base_uri.is_empty())</span>
    {
<span style = "background-color:#fdd">        return m_uri;
    }</span>
    else
    {
<span style = "background-color:#fdd">        return uri_builder(m_base_uri).append(m_uri).to_uri();</span>
    }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void details::_http_request::set_request_uri(const uri&amp; relative) { m_uri = relative; }</span>

utility::string_t details::_http_request::to_string() const
<span style = "background-color:#fdd">{
    utility::string_t result(m_method);
    result += _XPLATSTR(' ');
    if (this-&gt;m_uri.is_empty())</span>
    {
<span style = "background-color:#fdd">        result += _XPLATSTR('/');
    }</span>
    else
    {
<span style = "background-color:#fdd">        result += this-&gt;m_uri.to_string();</span>
    }

<span style = "background-color:#fdd">    result += _XPLATSTR(" HTTP/1.1\r\n");
    result += http_msg_base::to_string();
    return result;
}</span>

utility::string_t details::_http_response::to_string() const
<span style = "background-color:#fdd">{
    utility::string_t result(_XPLATSTR("HTTP/1.1 "));
    result += utility::conversions::details::to_string_t(m_status_code);
    result += ' ';</span>
    // If the user didn't explicitly set a reason phrase then we should have it default
    // if they used one of the standard known status codes.
<span style = "background-color:#fdd">    if (m_reason_phrase.empty())</span>
    {
<span style = "background-color:#fdd">        result += get_default_reason_phrase(status_code());
    }</span>
    else
    {
<span style = "background-color:#fdd">        result += m_reason_phrase;</span>
    }

<span style = "background-color:#fdd">    result += _XPLATSTR("\r\n");
    result += http_msg_base::to_string();
    return result;
}</span>

} // namespace http
} // namespace web</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>